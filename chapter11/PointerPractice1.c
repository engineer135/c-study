#include <stdio.h>

// TestFunc의 자료형은 void(*)(int) 이다. 여기서 int는 파라미터.
void TestFunc(int nParam) {
	printf("TestFunc() : %d\n", nParam);
}

int main(void) {	
	//int nData = 10;
	//printf("%d\n", nData);
	//*(int*)0x0018FF00 = 10; 주어진 Stack 영역이 맞다면.. 이것도 됨
	//printf("%d\n", *(int*)0x0018FF00);

	// 포인터 실습
	// 메모리 할당은 컴파일러가 하는데 ASLR 방식으로 프로세스 실행시마다 랜덤하게 할당된다. 보안상의 이유.
	// 실습할때는 이 기능을 끈다. 프로젝트 > 설정 > 구성속성 > 링커 > 임의 기준 주소를 아니오로 바꿈.
	
	// 아래처럼 변수 선언 후 값 초기화하면, 
	// 0x0018FF00 0x0018FF01 0x0018FF02 0x0018FF03 이 네 주소(int형은 4바이트)에 300이란 값이 들어가게 된다.	
	// 300은 16진수로 00 00 01 2c 
	// 메모리에는 2c 01 00 00 순으로 저장된다. 리틀 엔디안 방식. 역순으로 저장됨.

	// 직접지정
	int nData = 300;
	printf("%d\n", nData);

	// 간접지정(메모리에서 검색할때는 &pnData로 해야 나온다.
	int *pnData = &nData; // pnData(0x0018FEF4에 nData의 주소가 저장된다. 00 FF 18 00 이렇게 역순으로)
	pnData += 2; // 메모리에서 int 두개만큼(8yte) 우측으로 이동(pnData에 저장된 00 FF 18 00 > 08 FF 18 00 으로 값이 변경되고, pnData는 0018FF08을 가르킨다고 보면 됨!)
	*pnData = 300; // 우측으로 이동하고 그곳(0018FF08)에 300 값(2C 01 00 00)을 넣는다.

	// * 이게 간접이라는 표시	
	// int *pnData ===== int* pnData 같다.
	// *pnData =======> * (int*) ========> int 양쪽에 똔똔이라 int만 남는다.
	// 따라서 아래처럼 쓸수도 있다. nData 주소(0x0018FF00)에 600 값 저장하기.
	*((int*)0x0018FF00) = 600; // 직접지정

	// 하지만, 실제로는 메모리 주소를 알 수가 없다. 매번 달라지니까.
	// 그래서 포인터를 쓴다.
	*pnData = 500; //간접지정


	// 함수도 포인터가 된다.
	TestFunc(10);

	// &TestFunc로 가져온 주소값 0x004116C0
	((void(*)(int))0x004116C0)(10);
	((void(*)(int))41160)(10); //10진수로 바꿔도 잘 돌아간다.

	// 이것만 보면 포인터 뭐하러 쓰나 싶지만
	// 배열과 함께 할때 포인터의 유용성이 폭발한다.

	// 숫자 다섯개 받아서 sum해주는 함수가 있다고 치면, 
	// func(int, int, int, int, int) 이런식으로 매개변수를 다섯개 넘겨줘야하지만...
	// arr[5] = {10, 20, 30, 40, 50}; 이런 배열을 만들고
	// func(int *paList)으로 만들면 func(arr) 이렇게 호출할 수 있으니 얼마나 편한가!

	return 0;
}

