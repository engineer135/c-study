#include <stdio.h>
#include <stdlib.h>

int main(void) {
	// 파일 입출력
	// File이란 무엇인가!?
	// mp3 avi ppt ... 데이터 파일
	// exe dll ... 실행 파일
	// 파일의 본질은 Usermode에서 커널 모드로 진입할 수 있는 '인터페이스'
	// 파일의 특징 : 파일마다 고유의 I/O 버퍼가 있다. (없을 수도 있지만 default는 있다)
	
	// FileSystem(Fat32, NTFS...)으로 파일을 관리한다.
	// HDD = Hard Disk Drive = 자기 원판
	// 테이프(3.5인치 플로피디스크) = 1.44MB ㅋㅋ 동그란 원판 테입
	// 갑자기 생각나네.. 버리지 말껄.. 알록달록한거 많았는데..
	// 아무튼
	// 원판은 트랙과 섹터로 나눠짐.
	// 트랙은 안쪽부터 0 1 2 3... 섹터도 0 1 2 3 인덱스가 붙는다.
	// 섹터 하나당 512바이트. 
	// Test.avi 파일이 2번 트랙 4번 섹터에서 '시작'한다고 기록을 해놓는다.
	// 2번 트랙 돌면서 저장을 시작.. 가다가 다른 데이터가 저장돼있으면, 건너뛰어서 저장하고.. 그런식으로 기록
	// 이런식으로 정보를 저장해놓는 걸
	// FAT = File Allocation Table 시스템이라고 함

	// OS 설치시 File System 선택 필요
	// Format은 빈공간(원판)에 트랙, 섹터 만드는 작업이라고 보면 됨 -> 관리가 가능해짐!
	
	// FileSystem 만드는게 굉장히 어려움.. ㅋ
	// 파일의 논리구조는 '선형'구조 -> Streaming 가능
	// 스트리밍 -> 버퍼 -> Queue 한 세트로 따라다닌다고 보면 됨

	// File에는 I/O 버퍼가 존재
	// File은 Disk(보조기억장치)를 사용하는 방법 중 하나.
	// Disk는 크기가 크고, 속도가 느림
	// Ram은 크기 작고, 속도가 빠름
	// Disk를 양파 까듯이 까서 나열하면 하나의 완벽한 선형 구조로 나열이 가능. [][][][][][][]...
	// File은 입출력 지점(I/O Point)이 있다.
	// [0][1][2][3][4].. 하나당 50바이트라고 치고
	// 어느 파일에 100바이트 write가 일어나면 처음엔 입출력지점이 [0]에 위치해 있다가, (최초크기는 0)
	// [0][1] 까지 write하고 입출력지점이 [2]로 옮겨 간다.
	// 그리고 또 write가 일어나면, [2]부터 이어서 진행됨. 크기는 자동 증가. 이런식으로 진행됨

	// 텍스트 파일과 바이너리 파일
	// '-1'을 무엇으로 인식하느냐의 차이
	// EOF(End Of File)면 텍스트 파일
	// 그렇지 않으면 바이너리 파일
	
	// 'w' -> 무조건 생성. 이미 존재하면 삭제하고 생성
	FILE *fp;
	fopen_s(&fp, "Text.txt", "w");
	fprintf(fp, "Hello File I/O\n"); // 파일에 문자 씀
	fclose(fp);

	system("Text.txt"); // 파일 열기

	//FILE *fp2;
	//fopen_s(&fp2, "CON", "w");
	//fprintf(fp2, "Hello File I/O\n"); // 콘솔에 문자 씀
	//fclose(fp2);

	// 구조체 단위로 읽고 쓰기도 가능
	// 나머지 자세한 건 책을 봅시다.

	// Q&A
	// 데이터 -> 버퍼 -> 디스크
	// 이런 순서로 저장됨. 버퍼가 중간 다리?통로?라고 보면 될듯..

	return 0;
}