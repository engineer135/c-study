#include <stdio.h>
#include <stdlib.h>

void main(int argc, char **argv) {
	// 배열의 크기를 자유재졸 다룰 수 있으면 얼마나 좋을까!!!
	// 배열의 크기는 컴파일 시에 확정되어있어야 한다.
	// 사용자에게 배열 크기를 입력받아 배열을 만들 수 없다는 이야기. 얼마나 불편한가...
	// 하지만 동적할당을 쓰면 가능하다.
	// 근데 여기서 의아한게 scanf 일때는 사이즈를 안써줘서 괜찮은데, scanf_s는 어떻게 해야 하지?
	// 숫자를 입력받으면 4byte 할당하면 되지만... 문자열 입력받을때는???

	int sizeOfArray = 0;
	int *arr;
	int i, input;

	//printf("만들고 싶은 배열의 요소의 수 : ");
	//scanf_s("%d", &sizeOfArray, sizeof(int));

	// int arr[sizeOfArray] 와 동일한 크기의 배열 생성
	// malloc의 리턴형은 void * 형이므로 (int *)로 형변환해야 함.
	// malloc은 할당된 메모리의 시작 '주소'를 리턴한다는 사실을 기억해야한다.
	arr = (int*)malloc(sizeof(int) * sizeOfArray);

	// 1차원 배열이고, int형 포인터가 담긴 배열, 각각의 인덱스에는 동적할당된 메모리 주소값을 가리키는 포인터가 담겨있다고 생각하면 될듯 싶다.
	// 여기서 계속 헷갈렸던 것은
	int nData = 10;
	int *pnData = &nData;
	*pnData = 20; // 이 부분임... 포인터에 간접 참조 연산자가 붙어서 포인터가 가리키는 메모리 주소에 저장된 값을 변경할 수 있다.
	// 내가 착각했던 것은 배열에서 arr[0] = 20 이라는 구문이 있으면
	// *(arr+0) = 20 이렇게 해석하는게 맞는데
	// (arr+0) = 20 이런식으로 자꾸만 착각을 했다. 그래서 '아니 어떻게 메모리 주소를 20으로 바꿀 수 가 있지?' 자꾸 이렇게 생각한 것...
	// 헷갈리지 말자.
	
	printf("nData === %d\n", nData); //20

	
	for (i = 0; i < sizeOfArray; i++) {
		printf("입력\n");
		scanf_s("%d", &input, sizeof(int));
		arr[i] = input; 
		// 이부분이 이해가 안됐다. arr은 포인터 배열인데 왜 메모리 '주소(&input)'를 넣지 않고, '값(input)'을 넣을까?
		// 내가 이해한게 맞다면 arr = { {int*},{int*},{int*} } 이거 아닌가???
		// 응 아니야
		// malloc 하면 할당된 메모리 시작 주소가 리턴된다고 했다.
		// arr = (int*) 0x00286DD8; <<< 이 얘기는 주소를 int* 형으로 해석하겠다는 뜻인데.. *는 그냥 포인터 변수라는 표시일뿐이고, 자료형은 결국 int라는 얘기 아님?
		// arr[0] = *(arr + 0)
		// arr은 int형 변수이고, 동적할당시 12바이트를 했다고 치면, arr 변수에는 동적할당 메모리 시작 주소가 들어가 있을 것이고
		// 이 얘기는 arr[0] 즉 *(arr +0) 이 메모리 시작주소라는 얘기가 아니라
		// 메모리 시작주소는 &arr 여기 저장되어있음.
		
		// 정리해보면
		// malloc으로 동적할당해서 나온 주소가 0x006B6DD8 라고 가정하면
		// 이 주소를 가지고 있는 메모리 주소(&arr)는 0x0034FE64 라는 전혀 다른 주소이며
		// 이 주소의 값(*&arr = arr)은 D8 6D 6B 00 -----> 006B6DD8 동적할당해서 나온 주소가 저장되어 있는 것임( *& 함께 쓰면 상쇄되서 삭제됨 )
		// arr[0]에 input을 저장한다는 것은, input이 3이라고 가정하면
		// *(arr + 0) = 3 이라는 얘기! 이게 중요! 앞에 간접 연산자가 붙었다.
		// *(0x006B6DD8(동적할당해서 나온 주소) + 0) = 3 이라고 풀어 쓸 수 있다.
		// 결국 이 loop문을 돌면서 동적할당된 메모리에 값을 넣고 있는 것임.
		// 헷갈리지 말자.
	}

	for (i = 0; i < sizeOfArray; i++) {
		printf("출력 %d \n", arr[i]);
	}

	free(arr);




	


	// 2차원 배열의 동적할당은 어떻게? -> 포인터 배열을 이용한다. 배열의 각 원소들이 모두 포인터인 배열. 각 원소들은 다른 일차원 배열들을 가리킬 수 있다.
	int x, y;
	int **arr2; // 포인터에 대한 포인터 변수
	printf("arr[x][y]를 만들자\n");
	scanf_s("%d %d", &x, &y, sizeof(int), sizeof(int));

	// int*(int형 포인터) 타입의 원소를 x개 가지는 1차원 배열을 생성
	arr2 = (int**) malloc(sizeof(int *) * x);
	// 이건 아래랑 똑같은 얘기다. 다만 어떤 데이터가 들어가야하는지 명확하게 보여주려고 이렇게 쓴 것 뿐임!
	//arr2 = (int)malloc(sizeof(int) * x);

	// arr2 배열의 각 원소들은 int * 형이므로 다른 int 배열을 가리키고 싶어할듯?
	for (i = 0; i < x; i++) {
		// int 형의 원소를 y개 가지는 메모리를 동적할당해서 arr2에 연결
		// *(arr2 + i) <------ 여기에 동적할당된 메모리의 주소를 담는다. 동적할당 메모리 크기는 int*y 바이트.
		arr2[i] = (int*)malloc(sizeof(int) * y);
	}

	printf("생성완료!!\n");

	// 하지만 엄밀히 따지면 이렇게 만든 배열은 2차원 배열은 아니다. 
	// 2차원 배열은 원래 메모리에 연속적으로 존재해야 하기 때문.
	// 하지만 동적할당된 메모리 공간들이 연달아 존재한다는 보장이 없다. 
	// 그렇지만 2차원 배열처럼 arr[3][4] 식으로 원소에 접근이 가능하기 때문에 2차원 배열이라고 부른다.
	// arr[3][4]
	// *(*(arr + 3) + 4)
	// *(arr+3)				arr 배열의 네번째 원소 값 = int형 배열의 '주소값'
	// *('주소값' + 4)		해당 주소값이 가리키는 int형 배열의 다섯번째 원소 값에 접근하는 것과 같음.





	// arr[x][y]
	// arr[int**][int*]
	// TODO 1.값 담아보고 출력해보기
	// TODO 2.CHAR 형태 값 담아보고 출력해보기



	// 해제는 할당과 반대 순으로 해줘야 한다.
	for (i = 0; i<x; i++)
	{
		free(arr2[i]);
	}
	free(arr2);
	
	return 0;

}